// Processes the point clouds generated by the cnn by removing outliers
// Finds cloud centers to get joint locations
// Shows clouds

#include <iostream>
#include <string>
#include <cstdlib>
#include <map>

#include <pcl/io/pcd_io.h>
#include <pcl/point_types.h>
#include <pcl/filters/statistical_outlier_removal.h>
#include <pcl/visualization/cloud_viewer.h>

#include "H5Cpp.h"

using namespace std;
using namespace H5;

// For getting floats
//struct pyf
//{
//	float val;
//};

// For getting ints
//struct pyi
//{
//	int val;
//};

// Gives the RGB for the given label
void label_to_pix(int label, int& r, int& g, int& b, bool fix_lua = false)
{
	// LUA indexes from 1, fix by subtracting 1
	if (fix_lua)
	{
		label--;
	}

	// Non person
	if (label == 0)
	{
		r = 0;
		g = 0;
		b = 0;
	}

	// Head L
	else if (label == 1)
	{
		r = 255;
		g = 0;
		b = 0;
	}

	// Head R
	else if (label == 2)
	{
		r = 50;
		g = 0;
		b = 0;
	}

	// Torso L
	else if (label == 3)
	{
		r = 0;
		g = 0;
		b = 255;
	}

	// Torso R
	else if (label == 4)
	{
		r = 0;
		g = 0;
		b = 50;
	}

	// Upper Arm L
	else if (label == 5)
	{
		r = 255;
		g = 255;
		b = 0;
	}

	// Upper Arm R
	else if (label == 6)
	{
		r = 50;
		g = 50;
		b = 0;
	}

	// Lower Arm L
	else if (label == 7)
	{
		r = 0;
		g = 255;
		b = 255;
	}

	// Lower Arm R
	else if (label == 8)
	{
		r = 0;
		g = 50;
		b = 50;
	}

	// Upper Leg L
	else if (label == 9)
	{
		r = 0;
		g = 255;
		b = 0;
	}

	// Upper Leg R
	else if (label == 10)
	{
		r = 0;
		g = 50;
		b = 0;
	}

	// Lower Leg L
	else if (label == 11)
	{
		r = 255;
		g = 0;
		b = 255;
	}

	// Lower Leg R
	else if (label == 12)
	{
		r = 50;
		g = 0;
		b = 50;
	}
}

// Gives the label given the pix
void pix_to_label(int r, int g, int b, int& label, bool break_for_lua = false)
{
	// non person
	if (r == 0 && g == 0 && b == 0)
	{
		label = 0;
	}

	// Head L
	else if (r == 255 && g == 0 && b == 0)
	{
		label = 1;
	}

	// Head R
	else if (r == 50 && g == 0 && b == 0)
	{
		label = 2;
	}

	// Torso L
	else if (r == 0 && g == 0 && b == 255)
	{
		label = 3;
	}

	// Torso R
	else if (r == 0 && g == 0 && b == 50)
	{
		label = 4;
	}

	// Upper arm L
	else if (r == 255 && g == 255 && b == 0)
	{
		label = 5;
	}

	// Upper arm R
	else if (r == 50 && g == 50 && b == 0)
	{
		label = 6;
	}

	// Lower arm L
	else if (r == 0 && g == 255 && b == 255)
	{
		label = 7;
	}

	// Lower arm R
	else if (r == 0 && g == 50 && b == 50)
	{
		label = 8;
	}

	// Upper leg L
	else if (r == 0 && g == 255 && b == 0)
	{
		label = 9;
	}

	// Upper leg R
	else if (r == 0 && g == 50 && b == 0)
	{
		label = 10;
	}

	// Lower leg L
	else if (r == 255 && g == 0 && b == 255)
	{
		label = 11;
	}

	// Lower leg R
	else if (r == 50 && g == 0 && b == 50)
	{
		label = 12;
	}

	// Finally, add 1 for lua sake
	if (break_for_lua)
	{
		label++;
	}
}

// Gives the XYZ position in world of the point using assumed intrinsics
void get_world_XYZ(double depth, int h_index, int w_index, double& X, double& Y)
{
	// These are the intrinsics
	// TODO: make these configurable
	double focal_x = 580;
	double focal_y = 580;
	double center_x = 314;
	double center_y = 252;

	// X position
	X = ((h_index - center_y) * depth) / focal_y;

	// Y position
	Y = ((w_index - center_x) * depth) / focal_x;

	// Depth does not change
}

// Handles point clouds
class person_cloud
{
	private:

	// The max number of classes
	// TODO: make this automatic / configurable
	int num_classes;

	public:

	//pcl::PointCloud<pcl::PointXYZRGB>::Ptr cloud;

	// Holds point clouds for every separate body part
	// Keys are the labels
	map<int, pcl::PointCloud<pcl::PointXYZRGB>::Ptr> part_clouds;

	// The name of the file to load from
	string set_file_name;

	// Constructor
	// Needs a file to load the data from
	person_cloud(string file_name)
	{

		// Set the max number of classes
		num_classes = 13;

		// H5 file name
		set_file_name = file_name;

		// Initialize the clouds
		for (int i = 0; i < num_classes; i++)
		{
			// Blank point cloud
			pcl::PointCloud<pcl::PointXYZRGB>::Ptr temp(new pcl::PointCloud<pcl::PointXYZRGB>);

			// Add to map
			part_clouds[i] = temp;
		}

	}

	// Destructor
	~person_cloud()
	{
		// Not needed?
		// Delete all of the clouds
		//for (int i = 0; i < num_classes; i++)
		//{
		//	delete part_clouds[i];
		//	part_clouds[i] = NULL;
		//}
	}

	// Makes a cloud out of the given info
	// Need to call after running the creating the class
	void make_cloud(int image_index = 0)
	{
		// Loading python hdf5 files into c++
		// http://stackoverflow.com/questions/25568446/loading-data-from-hdf5-to-vector-in-c

		// Open the H5 file
		H5File file(set_file_name, H5F_ACC_RDONLY);

		// Name of the sub fields in the hdf5 file
		string data_name = "data";
		string true_name = "true";
		string pred_name = "predictions";

		// Open the data sets
		DataSet depth = file.openDataSet(data_name);
		DataSet truth = file.openDataSet(true_name);
		DataSet preds = file.openDataSet(pred_name);

		// Get the shape of the data sets (all have the same shape)
		hid_t dspace = H5Dget_space(depth.getId());
		hsize_t shape[3];
		H5Sget_simple_extent_dims(dspace, shape, NULL);

		// Get the height and width of the images
		int height = shape[1];
		int width = shape[2];

		// Data space for specifing the image to be loaded
		DataSpace depth_space = depth.getSpace();
		DataSpace preds_space = preds.getSpace();

		// The shape of the data to get, getting one image
		hsize_t get_shape[3];
		get_shape[0] = 1;
		get_shape[1] = height;
		get_shape[2] = width;

		// The offset, start at the selected image
		hsize_t image_at[3];
		image_at[0] = image_index;
		image_at[1] = 0;
		image_at[2] = 0;

		// Load the depth image
		float depth_image[1][height][width];
		depth_space.selectHyperslab(H5S_SELECT_SET, get_shape, image_at);
		depth.read(depth_image, PredType::NATIVE_FLOAT, DataSpace::ALL, depth_space);

		// Load the predictions
		float label_image[1][height][width];
		preds_space.selectHyperslab(H5S_SELECT_SET, get_shape, image_at);
		preds.read(label_image, PredType::NATIVE_FLOAT, DataSpace::ALL, preds_space);

		// Temporary point to hold values
		pcl::PointXYZRGB temp_point;

		// Holds the XYZ
		double temp_x, temp_y, temp_z;

		// Holds the RGB
		int temp_r, temp_g, temp_b;

		// Holds the label for the point
		int label;

		// Go through each point in the file at the specified index
		for (int h_index = 0; h_index < height; h_index++)
		{
			for (int w_index = 0; w_index < width; w_index++)
			{
				// Get the label at this point
				label = label_image[0][h_index][w_index];

				// Ignore non person points
				if (label != 0)
				{
					// Get the RGB of this point
					label_to_pix(label, temp_r, temp_g, temp_b, true);

					// Get the depth at this point
					temp_z = depth_image[0][h_index][w_index];

					// Get the XYZ of the point
					get_world_XYZ(temp_z, h_index, w_index, temp_x, temp_y);

					// Set the values in the temp point
					temp_point.x = temp_x;
					temp_point.y = temp_y;
					temp_point.z = temp_z;
					temp_point.r = temp_r;
					temp_point.g = temp_g;
					temp_point.b = temp_b;

					// Add the temp point to the cloud that corresponds to this label
					part_clouds[label]->points.push_back(temp_point);
				}
			}
		}
	}

	// Removes bad points from the cloud that are considered wrong
	// Pixels at the threshold, outliers
	void trim_cloud(double threshold=10.0)
	{

		// Go through each point and remove threshold points
		
		
	}
/*
	// Shows the cloud for visualization
	void show_cloud()
	{
		// Construct a combined cloud from all of the parts
		pcl::PointCloud<pcl::PointXYZRGB> cloud;
		cloud = *part_clouds[0];
		for (int i = 1; i < num_classes; i++)
		{
			cloud += *part_clouds[i];
		}

		pcl::visualization::CloudViewer viewer("Cloud View");

		viewer.showCloud(&cloud);

		// Spin lock until window exit
		while (!viewer.wasStopped())
		{

		}
	}
*/
};

int main(int argc, char** argv)
{
	// Print usage if not enough args
	if (argc < 3)
	{
		cout << "Needs arguments: file_name index" << endl;

		return 0;
	}

	// Name of the visualization file
	string set_file_name = argv[1];

	// Index to visualize
	int to_visualize_index = atoi(argv[2]);

	cout << "Using file: " << set_file_name << endl;
	cout << "At index: " << to_visualize_index << endl;

	// Make the cloud handler
	person_cloud the_cloud(set_file_name);

	// Make the cloud
	the_cloud.make_cloud(to_visualize_index);

	return 0;
}
